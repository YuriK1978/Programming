'''
1) все компсы и генэксп работают по принципу

[ВЫРАЖЕНИЕ/ПРЕОБРАЗОВАНИЕ for element in ИСТОЧНИК if УСЛОВИЕ]

читается это слева направо, что важно когда циклов больше 1.
!!! Для словаря обязательно указать КЛЮЧ:ЗНАЧЕНИЕ (Пример #8), иначе получится Set.
!!! Listcomps, dictcomps, setcomps - по сути одинаковые. Результатом их работы является коллекция: dict, set, list
!!! Генэксп не генерирует всю последовательность, как (Listcomps, dictcomps, setcomps).
Он берет значения по одному и ТОЛЬКО ТОГДА, когда я попрошу.
Генератор ленивый, он ничего не хочет делать прямо сейчас.  Его нужно заставить что-то сделать.
!!! Генэксп отлично сканирует построчно гигабайтные логи ошибок, не загружая в память.
Взял одну, на ее место записал другую.
2) принцип работы операций у листкомпс и генэксп одинаков, синтаксически различаются скобками
3) компсы (листкомпс, сеткомпс, дикткомпс) в результате своей работы формируют соответствующую коллекцию и занимают память
4) переменные созданные внутри компсов или генэкспа недоступны извне. Т.е. если в #1 написать print(e) - будет ошибка.
5) генэксп вернет объект генератора, а не коллекцию! при создании объекта он проверит источник, что может быть критично, если это какая то функция. Если источник не валидный то ошибка упадет при создании генератора, а не при попытке получить значение
6) генэксп ленивый, то есть ничего не делает и не занимает память пока не потребуется значение. Сгенерировав значение снова засыпает пока опять не попросят новое.
7) генэксп одноразовый, при исчерпании начинает бросать исключение, которое мы не увидим, если используем генератор в цикле for
8) генэксп может потенциально генерировать бесконечные последовательности, но он ничего не знает о порядке элементов или о их количестве (нет len)

Лично мое мнение -  если вам не нужна длина, слайсы, индексы, то нужно использовать генэскп, не только из-за экономии памяти, но и из-за ленивости, экономии процессорного времени.
Естественно важно помнить что даже pep-8 и дзен - это не закон, а рекомендации, наша конкретная реализация и подход должны диктоваться имеющимися условиями и решаемой задачей.
'''
import pprint

# 1
squares = [e * e for e in range(10) if e % 2 == 0] # и фильтр и преобразование

# 2
text = 'hello world'
words = [word.capitalize() for word in text.split()] # только преобразование

#3
ints = [-1, -2, 0, 3, -4]
positives = [e for e in ints if e > 0] # только фильтрация

#4 То же, что и 1:
squares2 = []
for e in range(10):
    if e % 2 == 0:
        squares2.append(e * e)
        
#5 # Сначала внешний цикл, потом вложенный, потом условие и перед всем выражение
letters = [letter for word in text.split() for letter in word if letter < 'l']

#6
matrix = [list(range(x, x + 3)) for x in range(3)]
#pprint.pprint(matrix, indent = 1, width = 15) 

#7 
unique_letters = {letter for word in text.split() for letter in word if letter < 'o'}

#8
alphabet = {index: letter for index, letter in enumerate('abcdefghijklnop', 1)}
# print({value: key for key, value in alphabet.items()}) # можно помиенять ключи и значения местами (но так делать не надо!)


#9.........GENERATOR expression..........
# Подходы теже - скобки круглые.

positives_gen = (e for e in ints if e > 0)
#print(positives_gen) # вернул объект: <generator object <genexpr> at 0x000001BF60913780>
#print(next(positives_gen)) # здесь генэксп взял значение, проверил, вернул первое значение и тут же уснл.

if __name__ == '__main__':
   print(next(positives_gen))
   